<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Project Sonar</title>
		<script src="http://localhost:8080/socket.io/socket.io.js"></script>    
        <script type="text/javascript" src="sonar_new.js"></script>
        	<script src="node_modules/tone/build/Tone.js"></script>

<link rel="shortcut icon" href="#" />

        <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.2.min.js"></script> 
        
        <script>
        
         var angle_given_moment;
        var direction_given_moment;
        var radio = 400;
        var values_items = {
        	
        		min:280, 
        		max:80, 
        		param_in	:"A",   //hasta 255 
        		state:"set", 
        		speed_transmision:50,
        		min_value:0, 
        		max_value:10,        		
        		x_circum:radio*1.1111111,
        		y_circum:radio*1.0888888,
        		w_square:radio*2.2222222,
        		h_square:radio*2.2222222,
        		radius_circum:radio,
        		largo_pata:radio*0.0111111,
        		largo_texto:radio*0.0166666,
        		delta_negativos:radio*0.0133333,
        		resolucion:10,
        		num_valores_delay:90, 
        		resolucion_grados:1,  //siempre entero 
        		speed_update:100,
        		max_amplitude_signal:100
        		
        		}
        
const vertices = [
  -1.0, 1.0, 0.0,
  -1.0, -1.0, 0.0,
  1.0, -1.0, 0.0,
  1.0, 1.0, 0.0
];
const indices = [0, 1, 2, 3];
const height = values_items.h_square;
const width = values_items.w_square;

const canvas1 = document.createElement("canvas");
canvas1.height = values_items.h_square;
canvas1.width = values_items.w_square;
const gl = canvas1.getContext("webgl");

// Create an empty buffer object to store vertex buffer
const vertex_buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.bindBuffer(gl.ARRAY_BUFFER, null);

// Create an empty buffer object to store Index buffer
const Index_Buffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

// Vertex shader source code
const vertCode = `
    attribute vec3 coordinates;
 
    void main(void) {
      gl_Position = vec4(coordinates, 1.0);
    }
  `;
const vertShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertShader, vertCode);
gl.compileShader(vertShader);

// Fragment shader
const fragCode = `
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
  
    uniform float u_width;
    uniform float u_height;
    uniform vec4 u_color1;
    uniform vec4 u_color2;
  
    void main(void) {
      vec2 st = gl_FragCoord.xy;
      float half_width = u_width / 2.0;
      float half_height = u_height / 2.0;

      float percent = (atan(st[0] - half_width, half_height - st[1]) - 3.14) / -0.785;
      gl_FragColor = mix(u_color1, u_color2, percent);
    }
  `;
const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragShader, fragCode);
gl.compileShader(fragShader);

// Create a shader program object to store
// the combined shader program
const shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertShader);
gl.attachShader(shaderProgram, fragShader);
gl.linkProgram(shaderProgram);
gl.useProgram(shaderProgram);

/*======= Associating shaders to buffer objects =======*/

// Bind vertex buffer object
gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

// Colors. vec4 [r, g, b, a]
const color1Loc = gl.getUniformLocation(shaderProgram, "u_color1");
gl.uniform4fv(color1Loc, [0, 0, 0, 1]);
const color2Loc = gl.getUniformLocation(shaderProgram, "u_color2");
gl.uniform4fv(color2Loc, [0, 1, 0, 1]);

// Width & height
const heightLoc = gl.getUniformLocation(shaderProgram, "u_height");
gl.uniform1f(heightLoc, height);
const widthLoc = gl.getUniformLocation(shaderProgram, "u_width");
gl.uniform1f(widthLoc, width);

// Get the attribute location
const coord = gl.getAttribLocation(shaderProgram, "coordinates");
gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(coord);
gl.enable(gl.DEPTH_TEST);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.viewport(0, 0, canvas1.width, canvas1.height);

// Draw the square
gl.drawElements(gl.TRIANGLE_FAN, indices.length, gl.UNSIGNED_SHORT, 0);


        
        
        
        
       
			   
			   
        
        
        </script>
    </head>
    
        <style>
    
    	.classProgress {
    	width: 100%;
    	background-color: grey;
		}
		.classBar {
    	width: 0px;
    	height: 30px;
    	background-color: green;
}
    
    </style>
	<script type="text/javascript">
		//parametros
	var start = true;
	var i = 0;	
	var mode = 'auto';
	function start_1() {
		start = true;
		i = 0;
	}
	function stop() {
		start = false;
		i = 0;
	}
	function set_values() {
		
				values_items.min = parseInt(document.getElementById('min').value);
				values_items.max = parseInt(document.getElementById('max').value);
				values_items.resolucion_grados = parseInt(document.getElementById('resolution').value);
				values_items.speed_transmision = parseInt(document.getElementById('speed').value);
				
				clearInterval(myTimer);
				myTimer = setInterval(interval_send, values_items.speed_transmision);
		
		
				min = circumB2circumA(values_items.min);
				max = values_items.max;
		
	}
	
	function onload_body() {
	
				document.getElementById('min').value = values_items.min;
				document.getElementById('max').value = values_items.max;
				document.getElementById('resolution').value = values_items.resolucion_grados;
				document.getElementById('speed').value = values_items.speed_transmision;
		
	
		
	}
	
	function mode_change(){
	
	if (mode == 'auto') {
		
		document.getElementById('mode_button').innerHTML = "Manual";
		mode = 'manual';	
		clearInterval(myTimer);
		
		
	}else {
		document.getElementById('mode_button').innerHTML = "Auto";
		mode = 'auto';	
		myTimer = setInterval(interval_send, values_items.speed_transmision);
	}	
	
	
	}
	
	</script>    
    
    <body onload="onload_body()">
    
   <table border="1" width = "100%" height = "1000">
		<tr>
		<td width="8%" valign="top">
		
		<table border="1" width = "100%">
		<tr>
		<td>
		
		<br>
		Min Angle:&nbsp;<label id="labelmin"></label><input type="text" id="min" size="3">
		 
		</td>
		</tr>
		<tr>
		<td>

		<br>
		Max Angle:&nbsp;<label id="labelmax"></label><input type="text" id="max" size="3">
		 
		</td>
		</tr>
		
		
		<tr>
		<td>

		<br>
		Resolucion grados:&nbsp;<label id="labelfreq"></label><input type="text" id="resolution" size="3">
	
		</td>
		</tr>
		<tr>
		<td>

		<br>
		Tiempo de actualizacion:&nbsp;<label id="labelspeed"></label><input type="text" id="speed" size="3">
		
		</td>
		</tr>
		<tr>
		<td>
		<button onclick="javascript:set_values()" id="setvalues_button">Set Values</button>
		
		</td>
		</tr>
		<tr>
		<td>
		<button onclick="javascript:start_1()" id="start_button">Start</button>
		
		</td>
		</tr>
		<tr>
		<td>
		<button onclick="javascript:stop()" id="stop_button">Stop</button>
		
		</td>
		</tr>
		<tr>
		<td>
		
			<button onclick="javascript:mode_change()" id="mode_button">Auto</button>

			</td>				
		</tr>
	
		
		 </table>
		
		</td>
		
		<td valign="top" align="center">
		
					<canvas style="border:1px solid #000000;" id="myCanvas" ></canvas>			
		
		</td>				
		</tr>

   
   
   
   </table>

    </body>
    
	<script type="text/javascript">
	

	
	var canvas = document.getElementById('myCanvas');

			var valor_recibido;
			
			var angulo;
			var distancia;
			
        		
			var stream = new Array();
			var stream_angles = new Array();        		        		
        		
			canvas.width  = values_items.w_square;
			canvas.height = values_items.h_square;;
			var ctx = canvas.getContext('2d');	
		      
		      
        		//var last_angle = 0;
       
            var socket = io.connect("localhost:8080"); 
            /*Initializing the connection with the server via websockets */
            
				//envío ángulos al arduino!!!
				var min = circumB2circumA(values_items.min);
				
				
				var max = values_items.max;
				var amplitud = max - min;
							
				var direccion = 'r';
				
				//canvas.addEventListener("click", function (e) { getCursorPosition(canvas, e,values_items,socket,mode);});
				
			   function interval_receive(d1, a, v)
			   {
				var angle1 = circumA2circumB(a);		
				//console.log(d1);		   
			   var repeated = 2;
  				//var tres_valores = {angle:angle1,direccion:d,valor:v,repeated:repeated};
			   draw_basic_lines(ctx,values_items);					
				draw_variable_lines(ctx,values_items,angle1,d1);
			   }
				
				         
            
					
            
            
				//recibo mensajes del servidor!!!            
				draw_basic_lines(ctx,values_items);
				
				
            
            socket.on("stream",function(message){  
            
            
               
					//console.log('---> 8 ----> '+message)
	
                msg_in = JSON.parse(message);
                					
					//var param_received = msg_in.inputParam;
					
					//console.log('--0--:'+msg_in);
											
					//angulo = parse(msg_in.angulo).toFixed(2);
					angulo = parseInt(msg_in.angulo,10);
					valor_recibido = parseFloat(msg_in.distancia).toFixed(2);
					direccion1 = msg_in.direccion
					interval_receive(direccion1, angulo, valor_recibido);
					//console.log(direccion1);



					});
					
	
 				
 				function interval_send(){ 
				
					var i_out = angulo_absoluto(i,amplitud)+2;
					//console.log(i_out);
	 	 			
	 			  var msg_out = {inputParam:values_items.param_in,inputAngle:i_out}
	 			  
	 			  angle_given_moment = i;
	 			  direction_given:_moment = direccion;
	 			  
	 			  var msg_json = JSON.stringify(msg_out);
	 			  if (start == true) {
	 			  socket.emit('event', msg_json);	
	 			  }
	 			  
	 			  //console.log('--0--  '+msg_out.inputAngle)
  					
  					if (i>=max) {direccion = 'l';}
  					if (i<=min) {direccion = 'r';}
  					
  					//cambio de direccion cuando llego al min y al max.
  					
  					if (direccion=='r') {
  					i = i + values_items.resolucion_grados;
  					}else {
  						i = i - values_items.resolucion_grados;
  					}
  						//speed_transmision es la velocidad a la que envio los angulos al ardu en ms.
  					
  					var angle1 = circumA2circumB(i);
  					console.log(angle1);
  					var repeated = 2;
  					var tres_valores = {angle:angle1,direccion:direccion,valor:valor_recibido,repeated:repeated};
  					stream.push(tres_valores);
					stream_angles.push(angle1);
  					if (stream.length > values_items.num_valores_delay) {
							stream.shift();
							stream_angles.shift();
					}
					//console.log(stream);
  					draw_basic_lines(ctx,values_items);					
					draw_variable_lines(ctx,stream,stream_angles,values_items,angle1);
  					
  					
	 				} 		   
 				
 				
 				
	</script>    
    
</html>